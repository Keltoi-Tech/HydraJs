"use strict";var e=require("knex"),t=require("axios");class Model{#e;constructor(e={}){this.#e=e}get key(){return this.#e}set key(e={}){this.#e=e}get entity(){return{}}static build(e={}){return new Model(e)}}var runWhenFalse=(e=Promise.resolve(!0),t=async()=>{})=>e.then((async e=>{e||await t()}));class Logged extends Model{#t=new Date;constructor({key:e={},createdAt:t=new Date}){super(e),this.#t=t}get createdAt(){return this.#t}set createdAt(e=new Date){this.createdAt=e}static makeMe(t=e(),s=Logged,n=(t=new e.TableBuilder)=>{}){return runWhenFalse(t.schema.hasTable(s.name),(()=>t.schema.createTable(s.name,(e=>{n(e),e.dateTime("createdAt").notNullable().defaultTo(t.fn.now())}))))}}class Traced extends Logged{#s=void 0|new Date;#n=!0;constructor({key:e={},createdAt:t=new Date,updatedAt:s=void 0|new Date,active:n=!0}){super({key:e,createdAt:t}),this.#n=n,this.#s=s}get updatedAt(){return this.#s}set updatedAt(e=new Date){this.#s=e}get active(){return this.#n}set active(e=!0){this.#n=e}tickUpdateNow(){this.#s=new Date}static makeMe(t=e(),s=Traced,n=(t=new e.TableBuilder)=>{}){return super.makeMe(t,s,(e=>{n(e),e.dateTime("updatedAt").nullable(),e.boolean("active").defaultTo(!0)}))}}class Linking{#r=new Model;#i=new Model;#a=Model;#o=Model;get Abscissa(){return this.#a}get Ordinate(){return this.#o}constructor(e=Model,t=Model,{abscissa:s=new e,ordinate:n=new t}){this.#a=e,this.#o=t,this.#r=s,this.#i=n}static build=({AbscissaModel:e=Model,OrdinateModel:t=Model,abscissa:s=new Model,ordinate:n=new Model})=>new Linking(e,t,{abscissa:s,ordinate:n});static makeMe(t=e(),s=Model,n=Model,r=(t=new e.TableBuilder)=>{}){const i=`${s.name}${n.name}`;return runWhenFalse(t.schema.hasTable(i),(()=>t.schema.createTable(i,(e=>{r(e)}))))}get abscissaKey(){return{idAbscissa:this.#r.key}}get ordinateKey(){return{idOrdinate:this.#i.key}}get key(){return{...this.abscissaKey,...this.ordinateKey}}get entity(){}get abscissa(){return this.#r}set abscissa(e=this.Abscissa.build()){this.#r=e}get ordinate(){return this.#i}set ordinate(e=this.Ordinate.build()){this.ordinate=e}}class Thing extends Model{#d;constructor({key:e={},name:t=""}){super(e),this.#d=t}get name(){return this.#d}set name(e=""){this.#d=e}get entity(){return{name:this.#d}}static makeMe(t=e(),s=Thing,n=255,r=(t=new e.TableBuilder)=>{}){return runWhenFalse(t.schema.hasTable(s.name),(()=>t.schema.createTable(s.name,(e=>{r(e),e.string(n).notNullable()}))))}}let s=class Context{#c;constructor(t=e()){this.#c=t}get db(){return this.#c}unitOfWork(...e){return this.#c.transaction().then((t=>{e.forEach((e=>e.context=t));const clean=()=>e.forEach((e=>e.resetContext()));return{done:()=>t.commit().then(clean),rollback:()=>t.rollback().then(clean)}}))}static instance(t=e()){return new Context(t)}async terraform(e=[]){const t=e.map((async e=>e.makeMe(this.#c)));console.log("Terraforming..."),await Promise.all(t)}},n=class Repository{#d="";myContext;Entity=Model;static anyOrError(e,t={code:0,message:""}){if(e)return e;throw t}static setOrEmpty(e=[],t=e=>e){return e.length?e.map(t):[]}constructor(e=Model,t=new s){this.#d=e.name,this.myContext=()=>t.db(this.#d),this.resetContext=()=>{this.myContext=()=>t.db(this.#d)},this.Entity=e}set context(t=e()){this.myContext=()=>t(this.#d)}create=(e=new Model)=>this.myContext().insert({...e.key,...e.entity}).then((()=>e));insert=(e=new Model)=>this.myContext().insert(e.entity,Object.keys(e.key)).then((t=>(e.key=t[0],e)));update=(e=new Model)=>this.myContext().where(e.key).update(e.entity).then((e=>e>0));delete=(e=new Model)=>this.myContext().where(e.key).del().then((e=>e>0));get=(e=new Model)=>this.myContext().where(e.key).first().then((e=>Repository.anyOrError(e,{code:404,message:"Not found"}))).then(this.Entity.build);list=()=>this.myContext().select().then((e=>Repository.setOrEmpty(e,this.Entity.build)))};class Context{#h;constructor(e=t.create({})){this.#h=e}get http(){return this.#h}}class Repository{#y;constructor(e=Model,t=new Context){this.#y=t,this.modelInstance=(t={})=>new e(t)}static queryString(e={}){return"?"+Object.entries(e).map((([e,t])=>`${e}=${t}`)).join("&")}get context(){return this.#y}}exports.ApiContext=Context,exports.ApiRepository=Repository,exports.ApiRestRepository=class RestRepository extends Repository{constructor(e=Model,t=new Context){super(e,t)}#l=(e="",t=void 0|{})=>this.context.http.get(t?`${e}${Repository.queryString(t)}`:e);get=(e="",t=void 0|{})=>this.#l(e,t).then((e=>this.modelInstance(e)));list=(e="",t=void 0|{})=>this.#l(e,t).then(((e=[])=>e.map((e=>this.modelInstance(e)))));create=(e="",t=new Model)=>this.context.http.post(e,t.entity);update=(e="",t=new Model)=>this.context.http.put(e,t.entity);change=(e="",t=new Model)=>this.context.http.patch(e,t.entity);delete=(e,t=new Model)=>this.context.http.delete(`/${e}`)},exports.DbContext=s,exports.DbLinked=class DbLinked{#m;#d="";myContext;constructor(e=Linking,t=new s){this.#d=e.name,this.myContext=()=>t.db(this.#d),this.#m=e}createBatch=(e=[new Linking])=>this.myContext().insert(e.map((e=>({...e.key,...e.entity})))).then((()=>e));create=(e=new Linking)=>this.myContext().insert({...e.key,...e.entity}).then((()=>e));insertOrdinatesByAbscissa=({abscissa:e=new Model,ordinates:t=[new Model]})=>{const s=t.map((t=>this.#m.build({abscissa:e,ordinate:t})));return this.createBatch(s)};insertAbscissasByOrdinate=({ordinate:e=new Model,abscissas:t=[new Model]})=>{const s=t.map((t=>this.#m.build({abscissa:t,ordinate:e})));return this.createBatch(s)};delete=(e=new Linking)=>this.myContext().where(e.key).del().then((e=>e>0));getAbscissasByOrdinate(e=new Linking){const t=e.Abscissa,s=e.Ordinate,n=Object.keys(e.abscissaKey),r=Object.keys(e.abscissa.key),i=n.map((e=>`${t.name}${s.name}.${e}`)),a=r.map((e=>`${t.name}.${e}`));return this.myContext().where(e.ordinateKey).select(`${t.name}.*`).join(t.name,(e=>i.forEach(((t,s)=>{e.on(t,a[s])})))).then((e=>e.map((e=>t.build(e)))))}getOrdinatesByAbscissa(e=new Linking){const t=e.Ordinate,s=e.Abscissa,n=Object.keys(e.ordinateKey),r=Object.keys(e.ordinate.key),i=n.map((e=>`${s.name}${t.name}.${e}`)),a=r.map((e=>`${t.name}.${e}`));return this.myContext().where(e.abscissaKey).select(`${t.name}.*`).join(t.name,(e=>i.forEach(((t,s)=>{e.on(t,a[s])})))).then((e=>e.map((e=>t.build(e)))))}},exports.DbLoggedRepository=class LoggedRepository extends n{constructor(e=Logged,t=new s){super(e,t)}get=(e=new Logged)=>this.myContext().where({...e.key}).first().then((e=>n.anyOrError(e,{code:404,message:"Not found"}))).then(this.Entity.build);before=(e=new Date,t="asc")=>this.myContext().where("createdAt","<",e.toISOString()).select().orderBy("createdAt",t).then((e=>n.setOrEmpty(e,this.Entity.build)));after=(e=new Date,t="asc")=>this.myContext().where("createdAt",">",e.toISOString()).select().orderBy("createdAt",t).then((e=>n.setOrEmpty(e,this.Entity.build)));list=(e="asc")=>this.myContext().select().orderBy("createdAt",e).then((e=>n.setOrEmpty(e,this.Entity.build)));insert=(e=new Logged)=>this.myContext().insert({...e.entity,createdAt:(new Date).toISOString()},Object.keys(e.key)).then((t=>e.key=t[0])).then((()=>e));create=(e=new Logged)=>this.myContext().insert({...e.entity,createdAt:(new Date).toISOString()}).then((()=>e));update=()=>Promise.reject(new Error("Cannot update a logged object"));delete=()=>Promise.reject(new Error("Cannot delete a logged object"))},exports.DbRepository=n,exports.DbThingRepository=class ThingRepository extends n{constructor(e=Thing,t=new s){super(e,t)}getByName=(e="")=>this.myContext().where({name:e}).select().then((e=>n.setOrEmpty(e,this.Entity.build)))},exports.DbTracedRepository=class TracedRepository extends n{constructor(e=Traced,t=new s){super(e,t)}deceased=(e="asc")=>this.myContext().where({active:!1}).select().orderBy(["createdAt","updatedAt"],e).then((e=>n.setOrEmpty(e,this.Entity.build)));before=(e=new Date,t="asc")=>this.myContext().where("createdAt","<",e.toISOString()).where({active:!0}).select().orderBy(["createdAt","updatedAt"],t).then((e=>n.setOrEmpty(e,this.Entity.build)));after=(e=new Date,t="asc")=>this.myContext().where("createdAt",">",e.toISOString()).where({active:!0}).select().orderBy(["createdAt","updatedAt"],t).then((e=>n.setOrEmpty(e,this.Entity.build)));list=(e="asc")=>this.myContext().where({active:!0}).select().orderBy(["createdAt","updatedAt"],e).then((e=>n.setOrEmpty(e,this.Entity.build)));last=()=>this.myContext().where({active:!0}).first().orderBy("createdAt","desc").then((e=>n.anyOrError(e,{code:404,message:"Not found"})));first=()=>this.myContext().where({active:!0}).first().orderBy("createdAt","asc").then((e=>n.anyOrError(e,{code:404,message:"Not found"})));insert=(e=new Traced)=>this.myContext().insert({...e.entity,createdAt:(new Date).toISOString()},Object.keys(e.key)).then((t=>e.key=t[0])).then((()=>e));create=(e=new Traced)=>this.myContext().insert({...e.key,...e.entity,createdAt:(new Date).toISOString()}).then((()=>e));update=(e=new Traced)=>this.myContext().where(e.key).update({...e.entity,updatedAt:(new Date).toISOString()}).then((e=>e>0));delete=(e=new Traced)=>this.myContext().where(e.key).update({active:!1,updatedAt:(new Date).toISOString()}).then((e=>e>0))},exports.Handler=class Handler{#y;constructor({context:e=new s}){this.#y=e}get context(){return this.#y}handle(){}handleError({code:e,message:t}){return Promise.reject({code:e,message:t})}},exports.Linking=Linking,exports.Logged=Logged,exports.Model=Model,exports.Service=class Service{#y;constructor(e=new s){this.#y=e}get context(){return this.#y}handleError=(e,t)=>Promise.reject({code:e,message:t});handleFailure=e=>this.handleError({code:500,message:e.message})},exports.Thing=Thing,exports.Traced=Traced,exports.runWhenFalse=runWhenFalse,exports.runWhenTrue=(e=Promise.resolve(!0),t=async()=>{})=>e.then((async e=>{e&&await t()}));

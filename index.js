"use strict";var e=require("knex"),t=require("axios");class Result{#e;#t;#s;constructor({code:e=0,message:t="",data:s={}}){this.#e=e,this.#t=t,this.#s=s}get error(){return{code:this.code,message:this.message}}get ok(){return{code:this.code,data:this.data}}sendError(e){e.status(this.#e).send(this.#t)}sendOk(e){e.status(this.#e).json(this.#s)}}class Model{#n;constructor(e={}){this.#n=e}get key(){return this.#n}set key(e={}){this.#n=e}get entity(){return{}}static build(e={}){return new Model(e)}}var runWhenFalse=(e=Promise.resolve(!0),t=async()=>{})=>e.then((async e=>{e||await t()}));class Logged extends Model{#r=new Date;constructor({key:e={},createdAt:t=new Date}){super(e),this.#r=t}get createdAt(){return this.#r}set createdAt(e=new Date){this.createdAt=e}static makeMe(t=e(),s=Logged,n=(t=new e.TableBuilder)=>{}){return runWhenFalse(t.schema.hasTable(s.name),(()=>t.schema.createTable(s.name,(e=>{n(e),e.dateTime("createdAt").notNullable().defaultTo(t.fn.now())}))))}}class Traced extends Logged{#a=void 0|new Date;#i=!0;constructor({key:e={},createdAt:t=new Date,updatedAt:s=void 0|new Date,active:n=!0}){super({key:e,createdAt:t}),this.#i=n,this.#a=s}get updatedAt(){return this.#a}set updatedAt(e=new Date){this.#a=e}get active(){return this.#i}set active(e=!0){this.#i=e}tickUpdateNow(){this.#a=new Date}static makeMe(t=e(),s=Traced,n=(t=new e.TableBuilder)=>{}){return super.makeMe(t,s,(e=>{n(e),e.dateTime("updatedAt").nullable(),e.boolean("active").defaultTo(!0)}))}}class Linking{#o=new Model;#d=new Model;#c=Model;#h=Model;get Abscissa(){return this.#c}get Ordinate(){return this.#h}constructor(e=Model,t=Model,{abscissa:s=new e,ordinate:n=new t}){this.#c=e,this.#h=t,this.#o=s,this.#d=n}static build=({AbscissaModel:e=Model,OrdinateModel:t=Model,abscissa:s=new Model,ordinate:n=new Model})=>new Linking(e,t,{abscissa:s,ordinate:n});static makeMe(t=e(),s=Model,n=Model,r=(t=new e.TableBuilder)=>{}){const a=`${s.name}${n.name}`;return runWhenFalse(t.schema.hasTable(a),(()=>t.schema.createTable(a,(e=>{r(e)}))))}get abscissaKey(){return{idAbscissa:this.#o.key}}get ordinateKey(){return{idOrdinate:this.#d.key}}get key(){return{...this.abscissaKey,...this.ordinateKey}}get entity(){}get abscissa(){return this.#o}set abscissa(e=this.Abscissa.build()){this.#o=e}get ordinate(){return this.#d}set ordinate(e=this.Ordinate.build()){this.ordinate=e}}class Thing extends Model{#l;constructor({key:e={},name:t=""}){super(e),this.#l=t}get name(){return this.#l}set name(e=""){this.#l=e}get entity(){return{name:this.#l}}static makeMe(t=e(),s=Thing,n=255,r=(t=new e.TableBuilder)=>{}){return runWhenFalse(t.schema.hasTable(s.name),(()=>t.schema.createTable(s.name,(e=>{r(e),e.string(n).notNullable()}))))}}let s=class Context{#y;constructor(t=e()){this.#y=t}get db(){return this.#y}unitOfWork(...e){return this.#y.transaction().then((t=>{e.forEach((e=>e.context=t));const clean=()=>e.forEach((e=>e.resetContext()));return{done:()=>t.commit().then(clean),rollback:()=>t.rollback().then(clean)}}))}static instance(t=e()){return new Context(t)}async terraform(e=[]){const t=e.map((async e=>e.makeMe(this.#y)));await Promise.all(t)}},n=class Repository{#l="";myContext;Entity=Model;static anyOrError(e,t={code:0,message:""}){if(e)return e;throw new Result(t)}static setOrEmpty(e=[],t=e=>e){return e.length?e.map(t):[]}constructor(e=Model,t=new s){this.#l=e.name,this.myContext=()=>t.db(this.#l),this.resetContext=()=>{this.myContext=()=>t.db(this.#l)},this.Entity=e}set context(t=e()){this.myContext=()=>t(this.#l)}create=(e=new Model)=>this.myContext().insert({...e.key,...e.entity}).then((()=>e));insert=(e=new Model)=>this.myContext().insert(e.entity,Object.keys(e.key)).then((t=>(e.key=t[0],e)));update=(e=new Model)=>this.myContext().where(e.key).update(e.entity).then((e=>e>0));delete=(e=new Model)=>this.myContext().where(e.key).del().then((e=>e>0));get=(e=new Model)=>this.myContext().where(e.key).first().then((e=>Repository.anyOrError(e,{code:404,message:"Not found"}))).then(this.Entity.build);list=()=>this.myContext().select().then((e=>Repository.setOrEmpty(e,this.Entity.build)))};class Context{#m;constructor(e=t.create({})){this.#m=e}get http(){return this.#m}}class Repository{#u;constructor(e=Model,t=new Context){this.#u=t,this.modelInstance=(t={})=>new e(t)}static queryString(e={}){return"?"+Object.entries(e).map((([e,t])=>`${e}=${t}`)).join("&")}get context(){return this.#u}}exports.ApiContext=Context,exports.ApiRepository=Repository,exports.ApiRestRepository=class RestRepository extends Repository{constructor(e=Model,t=new Context){super(e,t)}#g=(e="",t=void 0|{})=>this.context.http.get(t?`${e}${Repository.queryString(t)}`:e);get=(e="",t=void 0|{})=>this.#g(e,t).then((e=>this.modelInstance(e)));list=(e="",t=void 0|{})=>this.#g(e,t).then(((e=[])=>e.map((e=>this.modelInstance(e)))));create=(e="",t=new Model)=>this.context.http.post(e,t.entity);update=(e="",t=new Model)=>this.context.http.put(e,t.entity);change=(e="",t=new Model)=>this.context.http.patch(e,t.entity);delete=(e,t=new Model)=>this.context.http.delete(`/${e}`)},exports.DbContext=s,exports.DbLinked=class DbLinked{#p;#l="";myContext;constructor(e=Linking,t=new s){this.#l=e.name,this.myContext=()=>t.db(this.#l),this.#p=e}createBatch=(e=[new Linking])=>this.myContext().insert(e.map((e=>({...e.key,...e.entity})))).then((()=>e));create=(e=new Linking)=>this.myContext().insert({...e.key,...e.entity}).then((()=>e));insertOrdinatesByAbscissa=({abscissa:e=new Model,ordinates:t=[new Model]})=>{const s=t.map((t=>this.#p.build({abscissa:e,ordinate:t})));return this.createBatch(s)};insertAbscissasByOrdinate=({ordinate:e=new Model,abscissas:t=[new Model]})=>{const s=t.map((t=>this.#p.build({abscissa:t,ordinate:e})));return this.createBatch(s)};delete=(e=new Linking)=>this.myContext().where(e.key).del().then((e=>e>0));getAbscissasByOrdinate(e=new Linking){const t=e.Abscissa,s=e.Ordinate,n=Object.keys(e.abscissaKey),r=Object.keys(e.abscissa.key),a=n.map((e=>`${t.name}${s.name}.${e}`)),i=r.map((e=>`${t.name}.${e}`));return this.myContext().where(e.ordinateKey).select(`${t.name}.*`).join(t.name,(e=>a.forEach(((t,s)=>{e.on(t,i[s])})))).then((e=>e.map((e=>t.build(e)))))}getOrdinatesByAbscissa(e=new Linking){const t=e.Ordinate,s=e.Abscissa,n=Object.keys(e.ordinateKey),r=Object.keys(e.ordinate.key),a=n.map((e=>`${s.name}${t.name}.${e}`)),i=r.map((e=>`${t.name}.${e}`));return this.myContext().where(e.abscissaKey).select(`${t.name}.*`).join(t.name,(e=>a.forEach(((t,s)=>{e.on(t,i[s])})))).then((e=>e.map((e=>t.build(e)))))}},exports.DbLoggedRepository=class LoggedRepository extends n{constructor(e=Logged,t=new s){super(e,t)}get=(e=new Logged)=>this.myContext().where({...e.key}).first().then((e=>n.anyOrError(e,{code:404,message:"Not found"}))).then(this.Entity.build);before=(e=new Date,t="asc")=>this.myContext().where("createdAt","<",e.toISOString()).select().orderBy("createdAt",t).then((e=>n.setOrEmpty(e,this.Entity.build)));after=(e=new Date,t="asc")=>this.myContext().where("createdAt",">",e.toISOString()).select().orderBy("createdAt",t).then((e=>n.setOrEmpty(e,this.Entity.build)));list=(e="asc")=>this.myContext().select().orderBy("createdAt",e).then((e=>n.setOrEmpty(e,this.Entity.build)));insert=(e=new Logged)=>this.myContext().insert({...e.entity,createdAt:(new Date).toISOString()},Object.keys(e.key)).then((t=>e.key=t[0])).then((()=>e));create=(e=new Logged)=>this.myContext().insert({...e.entity,createdAt:(new Date).toISOString()}).then((()=>e));update=()=>Promise.reject(new Result({code:400,message:"Cannot update a logged object"}));delete=()=>Promise.reject(new Result({code:400,message:"Cannot delete a logged object"}))},exports.DbRepository=n,exports.DbThingRepository=class ThingRepository extends n{constructor(e=Thing,t=new s){super(e,t)}getByName=(e="")=>this.myContext().where({name:e}).select().then((e=>n.setOrEmpty(e,this.Entity.build)))},exports.DbTracedRepository=class TracedRepository extends n{constructor(e=Traced,t=new s){super(e,t)}deceased=(e="asc")=>this.myContext().where({active:!1}).select().orderBy(["createdAt","updatedAt"],e).then((e=>n.setOrEmpty(e,this.Entity.build)));before=(e=new Date,t="asc")=>this.myContext().where("createdAt","<",e.toISOString()).where({active:!0}).select().orderBy(["createdAt","updatedAt"],t).then((e=>n.setOrEmpty(e,this.Entity.build)));after=(e=new Date,t="asc")=>this.myContext().where("createdAt",">",e.toISOString()).where({active:!0}).select().orderBy(["createdAt","updatedAt"],t).then((e=>n.setOrEmpty(e,this.Entity.build)));list=(e="asc")=>this.myContext().where({active:!0}).select().orderBy(["createdAt","updatedAt"],e).then((e=>n.setOrEmpty(e,this.Entity.build)));last=()=>this.myContext().where({active:!0}).first().orderBy("createdAt","desc").then((e=>n.anyOrError(e,{code:404,message:"Not found"})));first=()=>this.myContext().where({active:!0}).first().orderBy("createdAt","asc").then((e=>n.anyOrError(e,{code:404,message:"Not found"})));insert=(e=new Traced)=>this.myContext().insert({...e.entity,createdAt:(new Date).toISOString()},Object.keys(e.key)).then((t=>e.key=t[0])).then((()=>e));create=(e=new Traced)=>this.myContext().insert({...e.key,...e.entity,createdAt:(new Date).toISOString()}).then((()=>e));update=(e=new Traced)=>this.myContext().where(e.key).update({...e.entity,updatedAt:(new Date).toISOString()}).then((e=>e>0));delete=(e=new Traced)=>this.myContext().where(e.key).update({active:!1,updatedAt:(new Date).toISOString()}).then((e=>e>0))},exports.Handler=class Handler{#u;constructor({context:e=new s}){this.#u=e}get context(){return this.#u}handle(){}handleError({code:e,message:t}){return Promise.reject(new Result({code:e,message:t}))}},exports.Linking=Linking,exports.Logged=Logged,exports.Model=Model,exports.Result=Result,exports.Service=class Service{#u;constructor(e=new s){this.#u=e}get context(){return this.#u}handleError=(e,t)=>Promise.reject(new Result({code:e,message:t}));handleFailure=e=>this.handleError({code:500,message:e.message})},exports.Thing=Thing,exports.Traced=Traced,exports.runWhenFalse=runWhenFalse,exports.runWhenTrue=(e=Promise.resolve(!0),t=async()=>{})=>e.then((async e=>{e&&await t()}));

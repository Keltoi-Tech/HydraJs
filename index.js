"use strict";var e=require("knex"),t=require("axios");class Model{#e;constructor(e={}){this.#e=e}get key(){return this.#e}set key(e={}){this.#e=e}get entity(){return{}}static build(e={}){return new Model(e)}}class Logged extends Model{#t=new Date;constructor({key:e={},createdAt:t=new Date}){super(e),this.#t=t}get createdAt(){return this.#t}set createdAt(e=new Date){this.createdAt=e}static makeMe(t=e(),s=Logged,n=(t=new e.TableBuilder)=>{}){return t.schema.createTable(s.name,(e=>{n(e),e.dateTime("createdAt").notNullable().defaultTo(t.fn.now())}))}}class Traced extends Logged{#s=void 0|new Date;#n=!0;constructor({key:e={},createdAt:t=new Date,updatedAt:s=void 0|new Date,active:n=!0}){super({key:e,createdAt:t}),this.#n=n,this.#s=s}get updatedAt(){return this.#s}set updatedAt(e=new Date){this.#s=e}get active(){return this.#n}set active(e=!0){this.#n=e}tickUpdateNow(){this.#s=new Date}static makeMe(t=e(),s=Traced,n=(t=new e.TableBuilder)=>{}){return t.schema.createTable(s.name,(e=>{n(e),e.dateTime("createdAt").notNullable().defaultTo(t.fn.now()),e.dateTime("updatedAt").nullable(),e.boolean("active").defaultTo(!0)}))}}class Linking{#r=new Model;#i=new Model;#a=Model;#o=Model;get Abscissa(){return this.#a}get Ordinate(){return this.#o}static build=({abscissa:e=new Model,ordinate:t=new Model})=>new Linking(Model,Model,{abscissa:e,ordinate:t});constructor(e=Model,t=Model,{abscissa:s=e.build(),ordinate:n=t.build()}){this.#a=e,this.#o=t,this.#r=s,this.#i=n}static makeMe(t=e(),s=Model,n=Model,r=(t=new e.TableBuilder)=>{}){return t.schema.createTable(`${s.name}${n.name}`,(e=>{r(e)}))}get abscissaKey(){return{idAbscissa:this.#r.key.id}}get ordinateKey(){return{idOrdinate:this.#i.key.id}}get key(){return{...this.abscissaKey,...this.ordinateKey}}get abscissa(){return this.#r}set abscissa(e=new Model){this.#r=e}get ordinate(){return this.#i}set ordinate(e=new Model){this.ordinate=e}}class Thing extends Model{#d;constructor({key:e={},name:t=""}){super(e),this.#d=t}get name(){return this.#d}set name(e=""){this.#d=e}get entity(){return{name:this.#d}}static makeMe(t=e(),s=Thing,n=(t=new e.TableBuilder)=>{}){return t.schema.createTable(s.name,(e=>{n(e),e.string(255).notNullable()}))}}let s=class Context{#c;constructor(t=e()){this.#c=t}get db(){return this.#c}unitOfWork(...e){return this.#c.transaction().then((t=>{e.forEach((e=>e.context=t));const clean=()=>e.forEach((e=>e.resetContext()));return{done:()=>t.commit().then(clean),rollback:()=>t.rollback().then(clean)}}))}static instance(t=e()){return new Context(t)}async terraform(e=[]){const t=e.map((async e=>{await this.#c.schema.hasTable(e.name)||await e.makeMe(this.#c)}));await Promise.all(t)}},n=class Repository{#d="";myContext;static anyOrError(e,t={code:0,message:""}){if(e)return e;throw t}static setOrEmpty(e=[],t=e=>e){return e.length?e.map(t):[]}constructor(e=Model,t=new s){this.#d=e.name,this.myContext=()=>t.db(this.#d),this.resetContext=()=>{this.myContext=()=>t.db(this.#d)},this.modelInstance=(t={})=>e.build(t)}set context(t=e()){this.myContext=()=>t(this.#d)}create=(e=new Model)=>this.myContext().insert({...e.key,...e.entity}).then((()=>e));insert=(e=new Model)=>this.myContext().insert(e.entity,Object.keys(e.key)).then((t=>e.key=t[0])).then((()=>e));update=(e=new Model)=>this.myContext().where(e.key).update(e.entity).then((e=>e>0));delete=(e={})=>this.myContext().where(e).del().then((e=>e>0));get=(e={})=>this.myContext().where(e).first().then((e=>Repository.anyOrError(e,{code:404,message:"Not found"}))).then(this.modelInstance);list=()=>this.myContext().select().then((e=>Repository.setOrEmpty(e,this.modelInstance)))};class Context{#h;constructor(e=t.create({})){this.#h=e}get http(){return this.#h}}class Repository{#l;constructor(e=Model,t=new Context){this.#l=t,this.modelInstance=(t={})=>new e(t)}static queryString(e={}){return"?"+Object.entries(e).map((([e,t])=>`${e}=${t}`)).join("&")}get context(){return this.#l}}exports.ApiContext=Context,exports.ApiRepository=Repository,exports.ApiRestRepository=class RestRepository extends Repository{constructor(e=Model,t=new Context){super(e,t)}#m=(e="",t=void 0|{})=>this.context.http.get(t?`${e}${Repository.queryString(t)}`:e);get=(e="",t=void 0|{})=>this.#m(e,t).then((e=>this.modelInstance(e)));list=(e="",t=void 0|{})=>this.#m(e,t).then(((e=[])=>e.map((e=>this.modelInstance(e)))));create=(e="",t=new Model)=>this.context.http.post(e,t.entity);update=(e="",t=new Model)=>this.context.http.put(e,t.entity);change=(e="",t=new Model)=>this.context.http.patch(e,t.entity);delete=(e,t=new Model)=>this.context.http.delete(`/${e}`)},exports.DbContext=s,exports.DbLinked=class DbLinked{#y;#d="";myContext;constructor(e=Linking,t=new s){this.#d=e.name,this.myContext=()=>t.db(this.#d),this.#y=e}#u=(e=[new Linking])=>this.myContext().insert(e.map((e=>e.key()))).then((()=>e));insert=(e=new Linking)=>{const t=e.key();return this.myContext().insert(t).then((()=>t))};insertOrdinatesByAbscissa=(e=new Model,t=[new Model])=>{const s=t.map((t=>this.#y.build({abscissa:e,o:t})));return this.#u(s)};insertAbscissasByOrdinate=(e=new Model,t=[new Model])=>{const s=t.map((t=>this.#y.build({a:t,ordinate:e})));return this.#u(s)};delete=(e=new Linking)=>this.myContext().where(e.key()).del().then((e=>e>0));abscissasByOrdinate=(e=new Linking)=>{const t=e.Abscissa,s=Object.keys(e.abscissaKey),n=s.map((e=>`${this.#d}.${e}`)),r=s.map((e=>`${t.name}.${e}`));return this.myContext().where(e.ordinateKey).select(n).join(t.name,(e=>n.forEach(((t,s)=>{e.on(t,r[s])})))).then((e=>e.map((e=>t.build(e)))))};ordinatesByAbscissa=(e=new Linking)=>{const t=e.Ordinate,s=Object.keys(e.ordinateKey),n=s.map((e=>`${this.#d}.${e}`)),r=s.map((e=>`${t.name}.${e}`));return this.myContext().where(e.abscissaKey).select(n).join(t.name,(e=>n.forEach(((t,s)=>{e.on(t,r[s])})))).then((e=>e.map((e=>t.build(e)))))}},exports.DbLoggedRepository=class TracedRepository extends n{constructor(e=Traced,t=new s){super(e,t)}deceased=()=>this.myContext().where({active:!1}).select().then((e=>n.setOrEmpty(e,this.modelInstance)));get=(e={})=>this.myContext().where({...e,active:!0}).first().then((e=>n.anyOrError(e,{code:404,message:"Not found"}))).then(this.modelInstance);before=(e=new Date)=>this.myContext().where("createdAt","<",e.toISOString()).select().then((e=>n.setOrEmpty(e,this.modelInstance)));after=(e=new Date)=>this.myContext().where("createdAt",">",e.toISOString()).select().then((e=>n.setOrEmpty(e,this.modelInstance)));list=()=>this.myContext().select().orderBy("createdAt","updatedAt").where({active:!0}).then((e=>n.setOrEmpty(e,this.modelInstance)));update=(e=new Logged)=>this.myContext().where(e.key).update({...e.entity,updatedAt:(new Date).toISOString()}).then((e=>e>0));delete=(e={})=>this.myContext().where(e).update({active:!1,updatedAt:(new Date).toISOString()}).then((e=>e>0))},exports.DbRepository=n,exports.DbThingRepository=class ThingRepository extends n{constructor(e=new s){super(model=Thing,e)}getByName=(e="")=>this.myContext().where({name:e}).select().then((e=>n.setOrEmpty(e,this.modelInstance)))},exports.DbTracedRepository=class TracedRepository extends n{constructor(e=Traced,t=new s){super(e,t)}before=(e=new Date)=>this.myContext().where("createdAt","<",e.toISOString()).select().then((e=>n.setOrEmpty(e,this.modelInstance)));after=(e=new Date)=>this.myContext().where("createdAt",">",e.toISOString()).select().then((e=>n.setOrEmpty(e,this.modelInstance)));list=()=>this.myContext().select().orderBy("createdAt").then((e=>n.setOrEmpty(e,this.modelInstance)));last=()=>this.myContext().first().orderBy("createdBy",order="desc").then((e=>n.anyOrError(e,{code:400,message:"Not found"})));first=()=>this.myContext().first().orderBy("createdBy",order="asc").then((e=>n.anyOrError(e,{code:400,message:"Not found"})));create=(e=new Traced)=>this.myContext().insert({...e.entity,createdAt:(new Date).toISOString()},Object.keys(model.key)).then((e=>model.key=e[0])).then((()=>model))},exports.Handler=class Handler{#l;constructor({context:e=new s}){this.#l=e}get context(){return this.#l}handle(){}handleError({code:e,message:t}){return Promise.reject({code:e,message:t})}},exports.Linking=Linking,exports.Logged=Logged,exports.Model=Model,exports.Service=class Service{#l;constructor(e=new s){this.#l=e}get context(){return this.#l}handleError=(e,t)=>Promise.reject({code:e,message:t});handleFailure=e=>this.handleError({code:500,message:e.message})},exports.Thing=Thing,exports.Traced=Traced;

"use strict";var t=require("knex"),e=require("axios");class Model{#t;constructor(t={}){this.#t=t}get key(){return this.#t}set key(t={}){this.#t=t}get entity(){return{}}}class Logged extends Model{#e=new Date;#n=void 0|new Date;#s=!0;constructor({key:t={},createdAt:e=new Date,updatedAt:n=void 0|new Date,active:s=!0}){super(t),this.#s=s,this.#n=n,this.#e=e}get createdAt(){return this.#e}set createdAt(t=new Date){this.createdAt=t}get updatedAt(){return this.#n}set updatedAt(t=new Date){this.#n=t}get active(){return this.#s}set active(t=!0){this.#s=t}static makeMe(e=t(),n=Model,s=(e=new t.TableBuilder)=>{}){return e.schema.createTable(n.name,(t=>{s(t),t.dateTime("createdAt").notNullable().defaultTo(e.fn.now()),t.dateTime("updatedAt").nullable(),t.boolean("active").defaultTo(!0)}))}}class Thing extends Model{#o;constructor({key:t={},name:e=""}){super(t),this.#o=e}get name(){return this.#o}set name(t=""){this.#o=t}get entity(){return{name:this.#o}}static makeMe(e=t(),n=Thing,s=(e=new t.TableBuilder)=>{}){return e.schema.createTable(n.name,(t=>{s(t),t.string(255).notNullable()}))}}let n=class Context{#r;constructor(e=t()){this.#r=e}get db(){return this.#r}unitOfWork(...t){return this.#r.transaction().then((e=>(t.forEach((t=>t.context=e)),{done:()=>e.commit().then((()=>t.forEach((t=>t.resetContext())))),rollback:()=>e.rollback().then((()=>t.forEach((t=>t.resetContext()))))})))}static instance(e=t()){return new Context(e)}async terraform(t=[]){const e=t.map((async t=>{await this.#r.schema.hasTable(t.name)||await t.makeMe(this.#r)}));await Promise.all(e)}},s=class Repository{#o="";myContext;static anyOrError(t,e={code:0,message:""}){if(t)return t;throw e}static setOrEmpty(t=[],e=t=>t){return t.length?t.map(e):[]}constructor(t=Model,e=new n){this.#o=t.name,this.myContext=()=>e.db(this.#o),this.resetContext=()=>{this.myContext=()=>e.db(this.#o)},this.modelInstance=(e={})=>new t(e)}set context(e=t()){this.myContext=()=>e(this.#o)}insert=(t=new Model)=>this.myContext().insert(t.entity,Object.keys(t.key)).then((e=>t.key=e[0])).then((()=>t));update=(t=new Model)=>this.myContext().where(t.key).update(t.entity).then((t=>t>0));delete=(t={})=>this.myContext().where(t).del().then((t=>t>0));get=(t={})=>this.myContext().where(t).first().then(Repository.anyOrError).then(this.modelInstance);list=()=>this.myContext().select().then((t=>Repository.setOrEmpty(t,this.modelInstance)))};class Context{#a;constructor(t=e.create({})){this.#a=t}get http(){return this.#a}}class Repository{#i;constructor(t=Model,e=new Context){this.#i=e,this.modelInstance=(e={})=>new t(e)}static queryString(t={}){return"?"+Object.entries(t).map((([t,e])=>`${t}=${e}`)).join("&")}get context(){return this.#i}}exports.ApiContext=Context,exports.ApiRepository=Repository,exports.ApiRestRepository=class RestRepository extends Repository{constructor(t=Model,e=new Context){super(t,e)}#h=(t="",e=void 0|{})=>this.context.http.get(e?`${t}${Repository.queryString(e)}`:t);get=(t="",e=void 0|{})=>this.#h(t,e).then((t=>this.modelInstance(t)));list=(t="",e=void 0|{})=>this.#h(t,e).then(((t=[])=>t.map((t=>this.modelInstance(t)))));create=(t="",e=new Model)=>this.context.http.post(t,e.entity);update=(t="",e=new Model)=>this.context.http.put(t,e.entity);change=(t="",e=new Model)=>this.context.http.patch(t,e.entity);delete=(t,e=new Model)=>this.context.http.delete(`/${t}`)},exports.DbContext=n,exports.DbLoggedRepository=class LoggedRepository extends s{constructor(t=Logged,e=new n){super(t,e)}deceased=()=>this.myContext().where({active:!1}).select().then((t=>t.map(this.modelInstance)));get=(t={})=>this.myContext().where({...t,active:!0}).first().then(this.modelInstance);before=(t=new Date)=>this.myContext().where("createdAt","<",t.toISOString()).select().then((t=>t.map(this.modelInstance)));after=(t=new Date)=>this.myContext().where("createdAt",">",t.toISOString()).select().then((t=>t.map(this.modelInstance)));list=()=>this.myContext().select().orderBy("createdAt","updatedAt").where({active:!0}).then((t=>t.map(this.modelInstance)));update=(t=new Logged)=>this.myContext().where(t.key).update({...t.entity,updatedAt:new Date}).then((t=>t>0));delete=(t={})=>this.myContext().where(t).update({updatedAt:(new Date).toISOString(),active:!1}).then((t=>t>0))},exports.DbRepository=s,exports.DbThingRepository=class ThingRepository extends s{constructor(t=new n){super(model=Thing,t)}getByName=(t="")=>this.myContext().where({name:t}).select().then((t=>this.modelInstance(t)))},exports.Logged=Logged,exports.Model=Model,exports.Thing=Thing;
